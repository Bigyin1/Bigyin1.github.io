<!DOCTYPE html>
<html lang=" en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>О терминалах | Home</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="О терминалах" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://bigyin1.github.io//2022/08/02/Term.html" />
<meta property="og:url" content="https://bigyin1.github.io//2022/08/02/Term.html" />
<meta property="og:site_name" content="Home" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-02T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="О терминалах" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-02T00:00:00+00:00","datePublished":"2022-08-02T00:00:00+00:00","headline":"О терминалах","mainEntityOfPage":{"@type":"WebPage","@id":"https://bigyin1.github.io//2022/08/02/Term.html"},"url":"https://bigyin1.github.io//2022/08/02/Term.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://bigyin1.github.io//feed.xml" title="Home" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Home</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">Обо Мне</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
    <div class="wrapper">
      <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">О терминалах</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-08-02T00:00:00+00:00" itemprop="datePublished">Aug 2, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ol id="markdown-toc">
  <li><a href="#полезные-ссылки" id="markdown-toc-полезные-ссылки">Полезные ссылки</a></li>
  <li><a href="#немного-важной-истории" id="markdown-toc-немного-важной-истории">Немного важной истории</a></li>
  <li><a href="#терминал-и-компьютер" id="markdown-toc-терминал-и-компьютер">Терминал и Компьютер</a>    <ol>
      <li><a href="#рассмотрим-блок-hardware" id="markdown-toc-рассмотрим-блок-hardware">Рассмотрим блок Hardware:</a></li>
      <li><a href="#теперь-к-блоку-software" id="markdown-toc-теперь-к-блоку-software">Теперь к блоку Software:</a></li>
    </ol>
  </li>
  <li><a href="#работа-терминала" id="markdown-toc-работа-терминала">Работа терминала</a>    <ol>
      <li><a href="#клавиатура" id="markdown-toc-клавиатура">Клавиатура</a></li>
      <li><a href="#экран" id="markdown-toc-экран">Экран</a></li>
    </ol>
  </li>
  <li><a href="#эмуляторы-терминалов" id="markdown-toc-эмуляторы-терминалов">Эмуляторы Терминалов</a></li>
  <li><a href="#драйвер-терминала-или-дисциплина-линии" id="markdown-toc-драйвер-терминала-или-дисциплина-линии">Драйвер терминала или дисциплина линии</a></li>
</ol>

<h2 id="полезные-ссылки">Полезные ссылки</h2>

<ol>
  <li><a href="http://www.linusakesson.net/programming/tty/">Старая, но часто цитируемая статья</a> и её <a href="https://ru.wikipedia.org/wiki/TTY-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F">перевод</a></li>
  <li>Linux API. Исчерпывающее руководство. Керриск Майкл. - отдельная глава о терминалах и псевдотерминалах.</li>
  <li><a href="https://pdos.csail.mit.edu/6.828">Учебная ОС xv6</a> и осбенно <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">книга</a> по ней.</li>
  <li><a href="https://vt100.net/docs/vt102-ug/">Документация</a> к одому из терминалов.</li>
  <li><a href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797">ANSI Escape Sequences</a></li>
  <li>man console_codes - описание всех кодов встроенной подсистемы tty Linux-а</li>
  <li>Эмулятор терминала <a href="http://git.suckless.org/st/files.html">st</a>.</li>
</ol>

<p>Мои дальнейшие заметки здесь являются, по большей части, подробным пересказом вышеприведенных ресурсов.</p>

<p>Сначала Я расскажу о работе обычных, т.е физических <a href="https://en.wikipedia.org/wiki/Computer_terminal#/media/File:DEC_VT100_terminal_transparent.png">терминалов</a>, которые были основным способом взаимодействия пользователя с компьютером в 60-80х годах. Они оказали немалое влияния на некоторые аспекты Unix-подобных операционных систем и продолжают существовать(будучи реализованными программно) и широко использоваться даже после своего физического исчезновения. Также затрону и современные эмуляторы терминалов. На Мой взгляд это крайне полезное знание, которое снимает множество вопросов при работе в Unix-подобных ОС.</p>

<h2 id="немного-важной-истории">Немного важной истории</h2>

<p>Сегодня с помощью клавиатуры, мыши и графического интерфейса Мы легко можем отдавать команды компьютеру - для нас это тривиальные действия. Но в 40-50х годах в распоряжении инженеров(основных пользователей ими же созданных компьютеров) не было ни мониторов, ни мышей, ни даже клавиатур как таковых. Как же тогда обычным пользователям взаимодействовать с компьютером не прибегая к трудозатратному вводу/выводу с помощью перфокарт? Решение оказалось совсем рядом, ведь клавиатура на самом деле уже была, правда в составе другого устройсва - печатной машинки. Какая удача, ведь вместе с клавиатурой мы сразу в комплекте получаем и лист бумаги, который может служить средой для вывода информации(свого рода монитором). Осталось лишь слегка передалать нашу машинку и подключить ее к компьютеру. Такая подключенная к компьютеру машинка получила два названия, которые и по сей день вносят сумятицу в компьютерную терминологию:</p>

<ul>
  <li>
    <p>Первое и наиболее часто используемое - терминал. В английском слово terminal означает некую сущность на которой все заканчивается. В русском языке это отразилось в словосочетании “терминал аэропорта”, ведь это место является конечным пунктом для рейса. Дабы не придумывать еще одно подобное слово, точку отправления рейса также называют терминалом. Лист в нашей печатной машинке как раз и является той самой конечной точкой для данных, а клавиатура точкой отправления данных.</p>
  </li>
  <li>
    <p>Второе - консоль. Здесь все интереснее и запутаннее. В общем случае слово console означает некий пульт управления, но так исторически сложилось, что консолью называли не любую печатную машинку, а только те с которых можно было осуществлять управление системой в целом(настройка, включение/выключение). Это была уже не маленькая печатная машинка, а <a href="https://en.wikipedia.org/wiki/System_console">целый стенд с кучей кнопок</a>, то есть консоль - это главный терминал компьютера(да, к древним компьютерам могло быть подключено сразу много терминалов). Со временем такие отдельно стоящие пульты управления исчезли, и все стало управляться с обычной клавиатуры, но название осталось. Им стали называть и обычные терминалы. На мой взгляд это вносит немалую путаницу в терминологию, поэтому далее я буду использовать только первое именование - <code class="language-plaintext highlighter-rouge">терминал</code>.</p>
  </li>
  <li>
    <p>На самом деле есть еще и третье - <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BB%D0%B5%D1%82%D0%B0%D0%B9%D0%BF">телетайп</a>, так называлась такая машинка будучи подкюченной не к компьютеру, а к другой такой машинке. Именно это устройство и было взято за основу инженерами при создании первых терминалов.</p>
  </li>
</ul>

<p>Очевидно, что с листом бумаги в качестве монитора на многое рассчитывать не приходится, и с развитием электроники он был заменен на <a href="https://vt100.net/dec/vt_history">экран</a>. Интерсно то, что этот экран был текстовым, то есть мог отображать лишь определенный набор символов, управлять цветом отдельных пикселей было нельзя. Позиция печати следующего символа указывалось положением <code class="language-plaintext highlighter-rouge">курсора</code> терминала. По сути это та же печатная машинка, но с текстовым дисплеем вместо листа бумаги. Очевидным преимуществом является возможность стирать произвольный символ и не бегать за бумагой. Такой механизм уже назывался непосредственно “терминал”, а точнее “видеотерминал”.</p>

<p>С исторей пока все, далее опишу как же осуществляется взаимодействие терминала с компьютером.</p>

<h2 id="терминал-и-компьютер">Терминал и Компьютер</h2>

<p>Сначала в общих чертах рассмотрим их взаимодействие, а затем подробнее разберём происходящее в терминале и ОС компьютера.</p>

<p>Без схем теперь не разобраться:</p>

<p><img src="/assets/img/posts/term/phys_term.png" alt="Phys Terminal" /></p>

<h3 id="рассмотрим-блок-hardware">Рассмотрим блок Hardware:</h3>

<p>Здесь схематично изображено подключение терминала к компьютеру. UART на схеме - это разъем в компьютере для подключения терминала, т.е терминал и компьютер взаимодействуют по <code class="language-plaintext highlighter-rouge">протоколу</code> UART. Это один из первых протоколов передачи данных физического уровня. В каком-то смысле это далёкий предок современного USB. Именно с помощью UART порта(также называемого Serial port) к старым компьютерам подключались терминалы, принтеры и даже другие компьютеры. Если не вдаваться в детали, то схема его работы очень проста: последовательная передача байтов в одну и в другую стороны. Так, например, нажатие кнопки на клавиатуре терминала приводит к отправке одного или нескольких байт в UART порт, а ОС компьютера может аналогично отправлять байты терминалу. Терминал определенным образом интерпретирует полученные символы, например печатает символ или передвигает курсор на новую строку, стирает строку, итд. То какие именно байты летают между терминалом и компьютером, расскажу позже.</p>

<p>Небольшое отсупление о протоколах и реализациях: выше Я упомянул сначала <code class="language-plaintext highlighter-rouge">протокол</code> UART, а затем UART порт. Протокол представляет собой описание схемы взаимодейтсвия, т.е это своего рода инструкция согласно которой мы должны организоввывать связь. UART порт - это реализация этого протокола с помощью микросхемы, управляющей передачей сигнала пр проводу. Подробнее можно прочиать <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">здесь</a>.</p>

<h3 id="теперь-к-блоку-software">Теперь к блоку Software:</h3>

<p>Будем рассматривать происходящее, предполагая, что компьютер находится под управление ОС семейсва Unix. Примеры будут на языке C.</p>

<p>Начнём с того, как пользовательскому процессу организовать доступ к терминалу.
Печатая что-либо на клавиатуре терминала мы, очевидно, хотим передать некие данные некой программе. Как же программа сможет получить эти данные и записать на экран терминала выходные данные?</p>

<p>Для взаимодействия с обычным файлом, мы должны “открыть” его в нашем процессе, получив файловый дескриптор:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int fd = open ("/path/to/file", flags)
</code></pre></div></div>
<p>Затем с его помощью можно производить операции над файлом в нашем процессе. При попытке, например, записи/чтения ОС поймет, что операции производятся над обычным(т.е находящимся на диске) файлом и с помощью драйвера диска выполнит запрос. Хорошо было бы организовать подобную схему для взаимодействия и с терминалом. В ОС семейтсва Unix именно так и делают.</p>

<p>Здесь Я не буду подробно описывать детали реализации(о них можно почитать в вышеупомянутой книге Керриска или xv6 book), скажу лишь то, что для терминала и других переферийных устройств ОС создаёт специальные <code class="language-plaintext highlighter-rouge">файлы устройств</code>, при взаимодействии с таким файлом(точнее с его файловым дескриптором) ОС использует соответсвующий драйвер устройства для взаимодействия. Файлы терминалов традиционно называются <code class="language-plaintext highlighter-rouge">tty</code>(опционально с каким-нибудь постфиксом). Это сокращение от слова teletype - выше Я не зря упоминал связь названий “телетайп” и “терминал”. Такие файлы можно в изобили найти в директории /dev.</p>

<p>Теперь обратим внимание на пунктирный прямоугольник. В нем перечислены части операционной системы, служащие для взаимодействия пользовательских процессов и терминала:</p>

<p>UART driver - это программа с помощью которой можно осуществлять чтение и запись в UART порт, а так как на другом конце UART-линии находится терминал, то это будут чтения/записи терминала. Также драйвер может позволять настраивать UART, например устанавливать скорость передачи и другие никоуровневые параметры. Пример такого драйвера из учебной ОС xv6: <a href="https://github.com/Bigyin1/xv6-riscv-fall19/blob/xv6-riscv-fall19/kernel/uart.c">тык</a>.</p>

<p>Казалось бы, драйвер UART предоставляет вполне достаточный набор функций - чтение и запись байтов, но создетели ОС Unix решили добавить еще один слой - специальный драйвер терминала, значильно расширяющий базовую функциональность. Именно он обрабатывает вызовы read/write для файловых дескрипторов терминалов(также еще есть вызов ioctl, с помощью которого осуществляется настройка драйвера). Далее мы увидим какие преимущества дало такое решение.</p>

<p>На схеме представлены блоки TTY driver и <code class="language-plaintext highlighter-rouge">Line discipline</code> - здесь выделены отдельно, но фактически Line discipline или “дисциплина линии” является непосредственной частью драйвера терминала, более того она составляет основу самого драйвера. Я точно не знаю от чего пошло столь странное название, поэтому просто скажу, что она особым образом обрабатывает байты, полученные(с помощью вышеописанного драйвера UART) от терминала. Подробный разбор схемы работы дисциплины линии(т.е драйвера терминала) будет позже.
Это здесь, если не терпится: <a href="#драйвер-терминала-или-дисциплина-линии">Драйвер терминала</a></p>

<h2 id="работа-терминала">Работа терминала</h2>

<p>Общая схема устройства терминала:</p>

<p><img src="/assets/img/posts/term/term_schema.png" alt="Phys Terminal" /></p>

<h3 id="клавиатура">Клавиатура</h3>

<p>Клавиатура одного из самых распространненых терминалов <a href="https://ru.wikipedia.org/wiki/VT100">VT100</a>, мало чем отличается от современных:
<img src="/assets/img/posts/term/term_keyboard.png" alt="Phys Terminal" /></p>

<p><a href="https://vt100.net/docs/vt102-ug/chapter4.html">Это</a> документация к клавиатуре терминала VT102 - Я буду часто на неё ссылаться.</p>

<p>Рассмотрим, что отправляется компьютеру при нажатии клавиш. Каждой клавише, очевидно, должен соответствовать некий цифровой код, состоящий из одного или нескольких байт. Дабы избежать всеобщей путаницы с кодами, они были стандартизированы. Для большинства клавиш стандартом является знаменитая 7-битная кодировка <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>. Она была специально создана для использования в телетайпах, а потом перекочевала в терминалы. Кодировка состоит из обычных и управляющих символов. Первые 32 символа и последний 128-й являются управляющими - это перевод строки, табуляция, окончание передачи, итд - <a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes">полный список с описанием</a>. Строго говоря, это не совсем симвлолы в привычном понимании, а управляющие коды с помощью которых можно контролировать работу как компьютера, так и самого терминала. Многие из них не используются по назаначению, так как имеют смысл только для старых “бумажных” телетайпов и терминалов или же просто устарели и более не востребованы. Позже Я подробнее поясню, то как коды этих клавиш обрабатываются компьютером и самим терминалом. Остальные символы - привычные нам печатаемые латинские буквы, цифры, знаки препинания - называются печатаемыми. При нажатии клавишу, например, <code class="language-plaintext highlighter-rouge">q</code> мы отправим его ASCII код <a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C">\x71</a> компьютеру, а при нажатии <code class="language-plaintext highlighter-rouge">Return</code> - код управляющего символа <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82_%D0%BA%D0%B0%D1%80%D0%B5%D1%82%D0%BA%D0%B8">CR</a>: <code class="language-plaintext highlighter-rouge">\x0D</code>.</p>

<p><strong>Важное замечание</strong>: при нажатии любой клавиши, её код отправляется компьютеру, но <strong>не</strong> передаётся экрану терминала, т.е чтобы напечатать введенный символ нужно явно отправить его терминалу из компьютера. Дело в том, что программам далеко не всегда нужно печатать на экран введенные пользователем данные, поэтому для большей гибкости применяется такой подход.</p>

<p>Также существуют т.н функциональные клавиши(стрелки, Escape, Ctrl, Caps Lock итд) - полный список в документации. Некоторые из них не передают никаких символов. Например Caps Lock и Shift - устанавливают регистр буквенных символов(как и по сей день). Отдельно стоит отметить клавишу Ctrl - она используется в связке с другими клавишами для генирования управляющих символов ASCII - в документации таблица 4-2. Механизм её работы таков: она зануляет старший бит кода нажатой вместей с ней клавиши. Напримиер, код клавиши <code class="language-plaintext highlighter-rouge">D</code> - <code class="language-plaintext highlighter-rouge">1000100</code> - при нажатии вместе с Ctrl превращается в <code class="language-plaintext highlighter-rouge">0000100</code> - управляющий символ с названием <code class="language-plaintext highlighter-rouge">EOT</code>. Такой способ ввода управляющих символов используется очень широко и получил собственное обозначение - т.н <a href="https://en.wikipedia.org/wiki/Caret_notation">caret notation</a>, т.е EOT также можно обозначить как <code class="language-plaintext highlighter-rouge">^D</code>.</p>

<p>Для некоторых наиболее часто используемых управляющих символов выделены отдельные клавишы: Back Space, Tab, Esc, Return, Line Feed, Enter(в правом нижнем углу клавиатуры).</p>

<p>Особое внимание стоит уделить клавишам <code class="language-plaintext highlighter-rouge">Return</code>, <code class="language-plaintext highlighter-rouge">Enter</code> и <code class="language-plaintext highlighter-rouge">Line Feed</code>. На современных клавиатурах остались <code class="language-plaintext highlighter-rouge">Return</code>(та, что с изогнутой стрелкой) и <code class="language-plaintext highlighter-rouge">Enter</code>. Мы не совсем осознанно называем клавишу <code class="language-plaintext highlighter-rouge">Return</code> “энтером”, а настоящую клавишу <code class="language-plaintext highlighter-rouge">Enter</code> обычно не используем. Дело в том, что исторически функции этих клавиш были одинаковы, за тем исключением, что <code class="language-plaintext highlighter-rouge">Enter</code> расположена в блоке клавиш под названием <a href="https://en.wikipedia.org/wiki/Numeric_keypad">Numeric Keypad</a>. Numeric Keypad - это своего рода отдельная мини-клавиатура когда-то использовавшаяся для более удобного взаимодействия с некоторыми программами. У неё есть два режима работы. В своём обычном режиме её клавиши генерируют те же коды, что и основная клавиатура, и тогда <code class="language-plaintext highlighter-rouge">Enter</code> <strong>эквивалентен</strong> <code class="language-plaintext highlighter-rouge">Return</code>. Очевидно, название <code class="language-plaintext highlighter-rouge">Enter</code> звучит более выразительно чем <code class="language-plaintext highlighter-rouge">Return</code>, и поэтому мы все используют именно его. Если интересно, то об этом также можно почитать в документации под таблицей 4-2(Я бы не рекомендовал - и так куча всего непонятного).</p>

<p>На клавише <code class="language-plaintext highlighter-rouge">Return</code> не зря изображено стрелка, указывающая налево. Данная клавиша генерирует управляющий символ с кодом <code class="language-plaintext highlighter-rouge">\x0D</code> чаще представляемый как <code class="language-plaintext highlighter-rouge">\r</code>(нотация из языка С). Называется он <code class="language-plaintext highlighter-rouge">carriage return</code>(CR) или “возврат каретки” и, будучу переданным терминалу, указывает ему перевести курсор к началу строки.</p>

<p>Клавиша <code class="language-plaintext highlighter-rouge">Line Feed</code>: здесь все интереснее. Она производит на свет повсеместно используемый управляющий символ <code class="language-plaintext highlighter-rouge">\x0A</code> или <code class="language-plaintext highlighter-rouge">\n</code> в нотации C. Правильно он называется не самым очевидным образом: <code class="language-plaintext highlighter-rouge">Linefeed</code>(LF) - перевод строки. Почему такой клавиши нет на современных клавиатурах? Откуда, в таком случае, мы получаем символ перевода строки? Сейчас расскажу коротко: драйвер терминала(точнее та самая дисциплина линии) заменяет символ клавиши <code class="language-plaintext highlighter-rouge">Return</code> - <code class="language-plaintext highlighter-rouge">\r</code> на <code class="language-plaintext highlighter-rouge">\n</code> или же (в зависимости от настройки) добавляет его после <code class="language-plaintext highlighter-rouge">\r</code> и поэтому клавиша <code class="language-plaintext highlighter-rouge">Line Feed</code> была убрана за ненадобностью. В следующем разделе Я подробнее пройдусь по этому вопросу.</p>

<p>Осталась последняя значимая группа клавиш: стрелки или как их называли тогда - клавишы управления курсором. Для их кодировки используется не ASCII, а специальные последовательности стандарта ANSI(сейчас это стандарт <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ECMA-48</a>) состоящие из <strong>ASCII символов</strong>. Называются они <code class="language-plaintext highlighter-rouge">ANSI Escape Sequences</code> или “Управляющие последовательнсоти ANSI”. Последовательнстей состоят из трех и более байт. Начинаются они с CSI - Control Sequence Introducer - двух байтов: <code class="language-plaintext highlighter-rouge">\x1B</code> и <code class="language-plaintext highlighter-rouge">[</code>. Первый из них назвается “Escape”(ESC). CSI нужна для того чтобы показать, что следующие символы нужно трактовать особым образом. После CSI идут аргументы последовательнсти, которые и определяют её. Например последовательность <code class="language-plaintext highlighter-rouge">ESC[2J</code> предназначена для стирания содержимого экрана терминала. Кстати, запись вида <code class="language-plaintext highlighter-rouge">\x1B</code> также называется escape последовательнсотью во многих языках программирования.</p>

<p>Небольшое отступление: Стандарт “Управляющих последовательнсотей ANSI” - это своего рода развитие концепции управляющих символов ASII, когда последних стало не достаточно для управления аппаратурой. Стоит отметить, что он включает в себя не только новые многобайтные последовательности, но также и некоторые старые управляющие символы ASII. В этом стандарте их группа называется “C0 control codes”.</p>

<p>Вернёмся к кодировкам наших стрелок. Как Я уже упомянул, их изначальным предназначением явлется управление курсором. Для этого существуют следующие ANSI последовательности:</p>

<p>Здесь CSI это <code class="language-plaintext highlighter-rouge">ESC[</code>.</p>

<p><img src="/assets/img/posts/term/escape_arrows.png" alt="Arrows" /></p>

<p>Как видно из описания этих четырех команд, n - это число клеток для перемещения с дефолтным значением 1. Тогда для перемещения на одну клетку n можно не указывать вовсе - как раз то, что нужно для стрелок. В документации в таблице 4-1 все они перечислены. Итак, нажатие любой из четырех стрелок генерирует трехбайтную последовательнсть отправляемую компьютеру.</p>

<p>Наверняка у вас возникло много вопросов касательно, того, зачем нужны все эти управляющие конструкции как ASCII, так и ANSI. Теперь настало время рассказать об экране нашего терминала.</p>

<h3 id="экран">Экран</h3>

<p>Экран терминала весьма незатейлив. Как Я уже писал, что управлять цветом отдельных пикселей, тут нельзя. Экран поделен на знакоместа сеткой строк и столбцов. Количество столбцов у терминала VT100 80 или 132 в зависимости от настроек. Для указания того знакоместа, где будет напечатан следующий символ существует <code class="language-plaintext highlighter-rouge">курсор</code>, который может перемещаться по знакоместам. Как Вы уже могли догадаться, львиная доля управляющих конструкций предназначена для передвижения курсора по экрану.</p>

<p><a href="https://vt100.net/docs/vt102-ug/chapter5.html">Документация</a> к обработке получаемых терминалом символов.</p>

<p>В начальном сотоянии курсор находится в позиции (0,0) - в левом верхнем углу.</p>

<p>Получая обычный(печатаемый) ASCII символ от компьютера, терминал печатает его на месте курсора и автоматимчески передвигает курсор на следующее знакоместо - было бы странно отправлять 3-х байтную ANSI последовательность перемпщения курсора после каждого символа.</p>

<p>При получении управляющей последовательности ANSI, терминал выполняет соответсвующую функцию. <a href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797">Здесь</a> можно посмотреть на них. Большая часть из них отвечает за перемещение курсора и удаление содержимого экрана, но таже есть, например, последовательности с помощью которых можно задавать цвет выводимиого текста.</p>

<p>В предыдущем разделе Я много писал про кнопки <code class="language-plaintext highlighter-rouge">Return</code>/<code class="language-plaintext highlighter-rouge">Enter</code> и <code class="language-plaintext highlighter-rouge">Line feed</code>. 
Кнопка <code class="language-plaintext highlighter-rouge">Return</code> отправляет <code class="language-plaintext highlighter-rouge">\r</code>(CR), а <code class="language-plaintext highlighter-rouge">Line feed</code> - <code class="language-plaintext highlighter-rouge">\n</code>(LF). <code class="language-plaintext highlighter-rouge">\r</code> - даёт команду терминалу вернуть курсор в начало <code class="language-plaintext highlighter-rouge">текущей</code> строки, а <code class="language-plaintext highlighter-rouge">\n</code> - сдвигает курсор на следующую строку, не меняя столбец. То есть для полноценного перевода строки терминалу нужно передать сразу обе этих символа CR и LF. Как Я писал выше, драйвер терминала в Unix-подобных ОС проводит обработку этих символов как при чтении из терминала, так и при записи в него. Это позволяет пользоваться лишь одной клавишей <code class="language-plaintext highlighter-rouge">Enter</code> и записывать в терминал только <code class="language-plaintext highlighter-rouge">\n</code> для перевода строки. Стоит заметить, что в других системах, например, Windows, требуется выводить сразу <code class="language-plaintext highlighter-rouge">\r\n</code>.</p>

<h2 id="эмуляторы-терминалов">Эмуляторы Терминалов</h2>

<p>В 80-х годах с развитием графических интерфейсов, терминалы были заменены на мониторы и клавиатуры общего назаначения, существующие и по сей день. К тому моменту уже существовало множество программ, нацеленных на работу именно с терминалом. Среди них крайне важные: текстовые редакторы(vi), командные оболочки(shell). Даже внутри Unix-подобных ОС появился ряд функций, заточенных под работу с терминалом. Да и вообще: сам способ терминального ввода/вывода отличался широкими возможностями при относительной простоте взаимодействия. Поэтому в таких системах терминалы начали реализовывать программно. Такие программы называюся эмуляторами терминалов или вртуальным терминалом в противовес обычным(физическим) терминалам. Связка клавиатура, монитора и эмулятора терминала по своим возможностям соответствует физическому терминалу.</p>

<p>Обычные терминалы помимо наличия монитора и клавиатуры обладают особой функциональностью, которую Я описывал ранее. Теперь же у нас есть только клавиатура, умеющая передавать коды символов, почти так же как и клвиатура терминала, но монитор, стал совсем “тупым” - он умеет только отрисовывать пиксели. Эмуляторы терминалов компенсируют эту утраченную функциональность.</p>

<p><img src="/assets/img/posts/term/term_emul.png" alt="Emul Terminal" /></p>

<p>На схеме выше изображена схема <code class="language-plaintext highlighter-rouge">подсистемы tty</code> встроенной в ядро ОС Linux. Как можно заметить, Terminal emulator принимает ввод с клавиатуры и выводит изображение на экран с помощью соответсвубщих драйверов. Обмен данными с драйвером терминала теперь реализуется в ядре ОС, без участия линии UART.</p>

<p>В ОС Linux вышеописаная система существует и по сей день. Называется она “Linux console” или просто - консолью. В самом начале Я упоминал, в каких случаях используется название “консоль” вместо “терминал”. Здесь как раз похожий случай, так как данная система - это единственный способ связи пользователя с ОС встроенный непосредственно в неё. Вы можете преклчиться на один из таких терминалов(их несколько) с помощью сочетания клвавиш Ctrl-Alt-F[1-6]. Однако сегодня мы в большинсттве случаев используеи графический интерфейс рабочего стола при работе с ОС. Как же нам получить доступ к эмулятору терминала оттуда, не прибегая к переключению на системную консоль Linux?</p>

<p>Программу эмулятор терминала можно создать в качестве пользовательского процесса, наравне с другими графическими приложениями, вроде браузера или текстового редактора. Пример такой программы на схеме выше - xterm. Напомню, что эмулятор терминала, будь то пользовательский или системный, выполняет функции физического терминала, но для полноценной работы он должен взаимодействовать с драйвером терминала. У системного терминала(консоли) с этим проблем нет, но пользовательское приложение может быть только конечной точкой взаимодействия(см. схемы) и не может само выполнять роль эмулятора терминала. Для решения этой проблемы был придуман механизм <code class="language-plaintext highlighter-rouge">псевдотерминалов</code>. Он позвволяет пользовательскому процессу получить доступ к <code class="language-plaintext highlighter-rouge">драйверу терминала(дисциплине линии)</code> с обеих сторон взаимодействия(см. схему ниже)</p>

<p><img src="/assets/img/posts/term/pty.png" alt="pty" /></p>

<h2 id="драйвер-терминала-или-дисциплина-линии">Драйвер терминала или дисциплина линии</h2>

<p>Драйвер терминала является связующим звеном между терминалом и программой. Он выполняет обработку входных и выходных данных. Я буду опираться на книгу М. Керриска, рекомендую заглянуть в главу о терминалах. Драйвер можно настраивать с помощью специальной структуры <code class="language-plaintext highlighter-rouge">termios</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct termios
  {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;			/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
  };
</code></pre></div></div>

<p>При запуске процесса из командной строки, эта структура(т.е настройки драйвера терминала) будут иметь дефолтное значние. При изменеии настроек драйвера вызовом <code class="language-plaintext highlighter-rouge">tcsetattr</code>, все процессы, использующие этот терминал, увидят изменения этих настроек.</p>

<p>Наибольшый интерес представляют поля: <code class="language-plaintext highlighter-rouge">c_iflag</code> - содержит функции обработки для входного потока символов, <code class="language-plaintext highlighter-rouge">c_oflag</code> - для выходного потока символов, <code class="language-plaintext highlighter-rouge">c_lflag</code> - для режима работы терминала, <code class="language-plaintext highlighter-rouge">c_cc</code> - содержит значения специальных символов терминала(об этом далее).</p>

<p>Драйвер терминала определяет набор специальных “символов”, принимая которые, он будет выполнять определенные действия. Кавычки Я добавил потому, что эти “символы” имеют определенное название, но их конкретное значение можно задать с помощью массива <code class="language-plaintext highlighter-rouge">c_cc</code>, кроме <code class="language-plaintext highlighter-rouge">CR</code> и <code class="language-plaintext highlighter-rouge">NL</code> - их значения фиксированы(<code class="language-plaintext highlighter-rouge">\r</code> и <code class="language-plaintext highlighter-rouge">\n</code>). Такой механизм позволяет гибче настраивать драйвер. Большая часть специальных символов имеют дефолтные значения.</p>

<p>В <code class="language-plaintext highlighter-rouge">c_lflag</code> содержатся такие важные функции как:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ECHO</code> - в включенном состоянии, автоматически отправяет терминалу, символы введенные пользователем. Непечатаемые символы отображаются в виде <code class="language-plaintext highlighter-rouge">^{A-^}</code>. Эта функция включена по умолчанию. Если её выключить, то программе нужно будет самой отправлять терминалу нужные для печати символы.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ICANON</code> - включает т.н канонический режим работы драйвера. Включен по умолчанию. У драйвера терминала есть специальный буфер для входных данных. В этом режиме драйвер не даёт доступ пользовательскому к данным во входном буфере сразу, а только после ввода специального символа перевода строки <code class="language-plaintext highlighter-rouge">NL</code> или специального символа <code class="language-plaintext highlighter-rouge">EOF</code>. Пока не введены эти сиволы, введенную строку можно редактировать: стирать символ, слово или всю строку, но перемещение курсора по строке не доступно. Такой подход позволяет многим пользовательским программам не реализовывать редактирование строки, а просто воспользоваться данным режимом. Для более продвинутого редактирования строки, такой режим нужно отключить и реализоваит весь функционал непосредственно в программе. Стоит отметить, что символ <code class="language-plaintext highlighter-rouge">NL</code> добавляется в буфер, а <code class="language-plaintext highlighter-rouge">EOF</code> - нет.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ISIG</code> - включает возможность отправлять сигналы процессам, испоьзующим данный терминал. Например, при получении символа с <code class="language-plaintext highlighter-rouge">INTR</code>, имеющем дефолтное значене Ctrl-C(<code class="language-plaintext highlighter-rouge">^C</code>), отправляется сигнал <code class="language-plaintext highlighter-rouge">SIGINT</code>, а при получении символа <code class="language-plaintext highlighter-rouge">SUSP</code> - <code class="language-plaintext highlighter-rouge">SIGTSTP</code>.</p>
  </li>
</ol>

<p>В <code class="language-plaintext highlighter-rouge">c_iflag</code> содержатся такой важный флаг, как <code class="language-plaintext highlighter-rouge">ICRNL</code>(включен по умолчанию). При активном флаге, драйвер терминала заменяет символ <code class="language-plaintext highlighter-rouge">CR</code>(<code class="language-plaintext highlighter-rouge">\r</code>) на  <code class="language-plaintext highlighter-rouge">NL</code>(<code class="language-plaintext highlighter-rouge">\n</code>). Аналогичный флаг <code class="language-plaintext highlighter-rouge">ONLCR</code> содержится в <code class="language-plaintext highlighter-rouge">c_oflag</code>. Если включён, то драйвер заменят <code class="language-plaintext highlighter-rouge">NL</code> на <code class="language-plaintext highlighter-rouge">CRNL</code> при выводе.</p>

<p>Еще немного про флаг <code class="language-plaintext highlighter-rouge">ICANON</code>…</p>


  </div><a class="u-url" href="/2022/08/02/Term.html" hidden></a>
</article>

    </div>
  </main><footer class="site-footer h-card">
  <data class="u-url" href="/%20/"></data>

  <div class="wrapper">

    <h2 class="footer-heading"></h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name"></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/Bigyin1"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Bigyin1</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

<script src='https://polyfill.io/v3/polyfill.min.js?features=es6'></script>
<script id=”MathJax-script” async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'></script>