<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://bigyin1.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://bigyin1.github.io//" rel="alternate" type="text/html" /><updated>2024-04-09T19:39:27+00:00</updated><id>https://bigyin1.github.io//feed.xml</id><title type="html">Home</title><entry><title type="html">О терминалах</title><link href="https://bigyin1.github.io//2022/08/02/Term.html" rel="alternate" type="text/html" title="О терминалах" /><published>2022-08-02T00:00:00+00:00</published><updated>2022-08-02T00:00:00+00:00</updated><id>https://bigyin1.github.io//2022/08/02/Term</id><content type="html" xml:base="https://bigyin1.github.io//2022/08/02/Term.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#полезные-ссылки" id="markdown-toc-полезные-ссылки">Полезные ссылки</a></li>
  <li><a href="#немного-важной-истории" id="markdown-toc-немного-важной-истории">Немного важной истории</a></li>
  <li><a href="#терминал-и-компьютер" id="markdown-toc-терминал-и-компьютер">Терминал и Компьютер</a>    <ol>
      <li><a href="#рассмотрим-блок-hardware" id="markdown-toc-рассмотрим-блок-hardware">Рассмотрим блок Hardware:</a></li>
      <li><a href="#теперь-к-блоку-software" id="markdown-toc-теперь-к-блоку-software">Теперь к блоку Software:</a></li>
    </ol>
  </li>
  <li><a href="#работа-терминала" id="markdown-toc-работа-терминала">Работа терминала</a>    <ol>
      <li><a href="#клавиатура" id="markdown-toc-клавиатура">Клавиатура</a></li>
      <li><a href="#экран" id="markdown-toc-экран">Экран</a></li>
    </ol>
  </li>
  <li><a href="#эмуляторы-терминалов" id="markdown-toc-эмуляторы-терминалов">Эмуляторы Терминалов</a></li>
  <li><a href="#драйвер-терминала-или-дисциплина-линии" id="markdown-toc-драйвер-терминала-или-дисциплина-линии">Драйвер терминала или дисциплина линии</a></li>
</ol>

<h2 id="полезные-ссылки">Полезные ссылки</h2>

<ol>
  <li><a href="http://www.linusakesson.net/programming/tty/">Старая, но часто цитируемая статья</a> и её <a href="https://ru.wikipedia.org/wiki/TTY-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F">перевод</a></li>
  <li>Linux API. Исчерпывающее руководство. Керриск Майкл. - отдельная глава о терминалах и псевдотерминалах.</li>
  <li><a href="https://pdos.csail.mit.edu/6.828">Учебная ОС xv6</a> и осбенно <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">книга</a> по ней.</li>
  <li><a href="https://vt100.net/docs/vt102-ug/">Документация</a> к одому из терминалов.</li>
  <li><a href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797">ANSI Escape Sequences</a></li>
  <li>man console_codes - описание всех кодов встроенной подсистемы tty Linux-а</li>
  <li>Эмулятор терминала <a href="http://git.suckless.org/st/files.html">st</a>.</li>
</ol>

<p>Мои дальнейшие заметки здесь являются, по большей части, подробным пересказом вышеприведенных ресурсов.</p>

<p>Сначала Я расскажу о работе обычных, т.е физических <a href="https://en.wikipedia.org/wiki/Computer_terminal#/media/File:DEC_VT100_terminal_transparent.png">терминалов</a>, которые были основным способом взаимодействия пользователя с компьютером в 60-80х годах. Они оказали немалое влияния на некоторые аспекты Unix-подобных операционных систем и продолжают существовать(будучи реализованными программно) и широко использоваться даже после своего физического исчезновения. Также затрону и современные эмуляторы терминалов. На Мой взгляд это крайне полезное знание, которое снимает множество вопросов при работе в Unix-подобных ОС.</p>

<h2 id="немного-важной-истории">Немного важной истории</h2>

<p>Сегодня с помощью клавиатуры, мыши и графического интерфейса Мы легко можем отдавать команды компьютеру - для нас это тривиальные действия. Но в 40-50х годах в распоряжении инженеров(основных пользователей ими же созданных компьютеров) не было ни мониторов, ни мышей, ни даже клавиатур как таковых. Как же тогда обычным пользователям взаимодействовать с компьютером не прибегая к трудозатратному вводу/выводу с помощью перфокарт? Решение оказалось совсем рядом, ведь клавиатура на самом деле уже была, правда в составе другого устройсва - печатной машинки. Какая удача, ведь вместе с клавиатурой мы сразу в комплекте получаем и лист бумаги, который может служить средой для вывода информации(свого рода монитором). Осталось лишь слегка передалать нашу машинку и подключить ее к компьютеру. Такая подключенная к компьютеру машинка получила два названия, которые и по сей день вносят сумятицу в компьютерную терминологию:</p>

<ul>
  <li>
    <p>Первое и наиболее часто используемое - терминал. В английском слово terminal означает некую сущность на которой все заканчивается. В русском языке это отразилось в словосочетании “терминал аэропорта”, ведь это место является конечным пунктом для рейса. Дабы не придумывать еще одно подобное слово, точку отправления рейса также называют терминалом. Лист в нашей печатной машинке как раз и является той самой конечной точкой для данных, а клавиатура точкой отправления данных.</p>
  </li>
  <li>
    <p>Второе - консоль. Здесь все интереснее и запутаннее. В общем случае слово console означает некий пульт управления, но так исторически сложилось, что консолью называли не любую печатную машинку, а только те с которых можно было осуществлять управление системой в целом(настройка, включение/выключение). Это была уже не маленькая печатная машинка, а <a href="https://en.wikipedia.org/wiki/System_console">целый стенд с кучей кнопок</a>, то есть консоль - это главный терминал компьютера(да, к древним компьютерам могло быть подключено сразу много терминалов). Со временем такие отдельно стоящие пульты управления исчезли, и все стало управляться с обычной клавиатуры, но название осталось. Им стали называть и обычные терминалы. На мой взгляд это вносит немалую путаницу в терминологию, поэтому далее я буду использовать только первое именование - <code class="language-plaintext highlighter-rouge">терминал</code>.</p>
  </li>
  <li>
    <p>На самом деле есть еще и третье - <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BB%D0%B5%D1%82%D0%B0%D0%B9%D0%BF">телетайп</a>, так называлась такая машинка будучи подкюченной не к компьютеру, а к другой такой машинке. Именно это устройство и было взято за основу инженерами при создании первых терминалов.</p>
  </li>
</ul>

<p>Очевидно, что с листом бумаги в качестве монитора на многое рассчитывать не приходится, и с развитием электроники он был заменен на <a href="https://vt100.net/dec/vt_history">экран</a>. Интерсно то, что этот экран был текстовым, то есть мог отображать лишь определенный набор символов, управлять цветом отдельных пикселей было нельзя. Позиция печати следующего символа указывалось положением <code class="language-plaintext highlighter-rouge">курсора</code> терминала. По сути это та же печатная машинка, но с текстовым дисплеем вместо листа бумаги. Очевидным преимуществом является возможность стирать произвольный символ и не бегать за бумагой. Такой механизм уже назывался непосредственно “терминал”, а точнее “видеотерминал”.</p>

<p>С исторей пока все, далее опишу как же осуществляется взаимодействие терминала с компьютером.</p>

<h2 id="терминал-и-компьютер">Терминал и Компьютер</h2>

<p>Сначала в общих чертах рассмотрим их взаимодействие, а затем подробнее разберём происходящее в терминале и ОС компьютера.</p>

<p>Без схем теперь не разобраться:</p>

<p><img src="/assets/img/posts/term/phys_term.png" alt="Phys Terminal" /></p>

<h3 id="рассмотрим-блок-hardware">Рассмотрим блок Hardware:</h3>

<p>Здесь схематично изображено подключение терминала к компьютеру. UART на схеме - это разъем в компьютере для подключения терминала, т.е терминал и компьютер взаимодействуют по <code class="language-plaintext highlighter-rouge">протоколу</code> UART. Это один из первых протоколов передачи данных физического уровня. В каком-то смысле это далёкий предок современного USB. Именно с помощью UART порта(также называемого Serial port) к старым компьютерам подключались терминалы, принтеры и даже другие компьютеры. Если не вдаваться в детали, то схема его работы очень проста: последовательная передача байтов в одну и в другую стороны. Так, например, нажатие кнопки на клавиатуре терминала приводит к отправке одного или нескольких байт в UART порт, а ОС компьютера может аналогично отправлять байты терминалу. Терминал определенным образом интерпретирует полученные символы, например печатает символ или передвигает курсор на новую строку, стирает строку, итд. То какие именно байты летают между терминалом и компьютером, расскажу позже.</p>

<p>Небольшое отсупление о протоколах и реализациях: выше Я упомянул сначала <code class="language-plaintext highlighter-rouge">протокол</code> UART, а затем UART порт. Протокол представляет собой описание схемы взаимодейтсвия, т.е это своего рода инструкция согласно которой мы должны организоввывать связь. UART порт - это реализация этого протокола с помощью микросхемы, управляющей передачей сигнала пр проводу. Подробнее можно прочиать <a href="https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter">здесь</a>.</p>

<h3 id="теперь-к-блоку-software">Теперь к блоку Software:</h3>

<p>Будем рассматривать происходящее, предполагая, что компьютер находится под управление ОС семейсва Unix. Примеры будут на языке C.</p>

<p>Начнём с того, как пользовательскому процессу организовать доступ к терминалу.
Печатая что-либо на клавиатуре терминала мы, очевидно, хотим передать некие данные некой программе. Как же программа сможет получить эти данные и записать на экран терминала выходные данные?</p>

<p>Для взаимодействия с обычным файлом, мы должны “открыть” его в нашем процессе, получив файловый дескриптор:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int fd = open ("/path/to/file", flags)
</code></pre></div></div>
<p>Затем с его помощью можно производить операции над файлом в нашем процессе. При попытке, например, записи/чтения ОС поймет, что операции производятся над обычным(т.е находящимся на диске) файлом и с помощью драйвера диска выполнит запрос. Хорошо было бы организовать подобную схему для взаимодействия и с терминалом. В ОС семейтсва Unix именно так и делают.</p>

<p>Здесь Я не буду подробно описывать детали реализации(о них можно почитать в вышеупомянутой книге Керриска или xv6 book), скажу лишь то, что для терминала и других переферийных устройств ОС создаёт специальные <code class="language-plaintext highlighter-rouge">файлы устройств</code>, при взаимодействии с таким файлом(точнее с его файловым дескриптором) ОС использует соответсвующий драйвер устройства для взаимодействия. Файлы терминалов традиционно называются <code class="language-plaintext highlighter-rouge">tty</code>(опционально с каким-нибудь постфиксом). Это сокращение от слова teletype - выше Я не зря упоминал связь названий “телетайп” и “терминал”. Такие файлы можно в изобили найти в директории /dev.</p>

<p>Теперь обратим внимание на пунктирный прямоугольник. В нем перечислены части операционной системы, служащие для взаимодействия пользовательских процессов и терминала:</p>

<p>UART driver - это программа с помощью которой можно осуществлять чтение и запись в UART порт, а так как на другом конце UART-линии находится терминал, то это будут чтения/записи терминала. Также драйвер может позволять настраивать UART, например устанавливать скорость передачи и другие никоуровневые параметры. Пример такого драйвера из учебной ОС xv6: <a href="https://github.com/Bigyin1/xv6-riscv-fall19/blob/xv6-riscv-fall19/kernel/uart.c">тык</a>.</p>

<p>Казалось бы, драйвер UART предоставляет вполне достаточный набор функций - чтение и запись байтов, но создетели ОС Unix решили добавить еще один слой - специальный драйвер терминала, значильно расширяющий базовую функциональность. Именно он обрабатывает вызовы read/write для файловых дескрипторов терминалов(также еще есть вызов ioctl, с помощью которого осуществляется настройка драйвера). Далее мы увидим какие преимущества дало такое решение.</p>

<p>На схеме представлены блоки TTY driver и <code class="language-plaintext highlighter-rouge">Line discipline</code> - здесь выделены отдельно, но фактически Line discipline или “дисциплина линии” является непосредственной частью драйвера терминала, более того она составляет основу самого драйвера. Я точно не знаю от чего пошло столь странное название, поэтому просто скажу, что она особым образом обрабатывает байты, полученные(с помощью вышеописанного драйвера UART) от терминала. Подробный разбор схемы работы дисциплины линии(т.е драйвера терминала) будет позже.
Это здесь, если не терпится: <a href="#драйвер-терминала-или-дисциплина-линии">Драйвер терминала</a></p>

<h2 id="работа-терминала">Работа терминала</h2>

<p>Общая схема устройства терминала:</p>

<p><img src="/assets/img/posts/term/term_schema.png" alt="Phys Terminal" /></p>

<h3 id="клавиатура">Клавиатура</h3>

<p>Клавиатура одного из самых распространненых терминалов <a href="https://ru.wikipedia.org/wiki/VT100">VT100</a>, мало чем отличается от современных:
<img src="/assets/img/posts/term/term_keyboard.png" alt="Phys Terminal" /></p>

<p><a href="https://vt100.net/docs/vt102-ug/chapter4.html">Это</a> документация к клавиатуре терминала VT102 - Я буду часто на неё ссылаться.</p>

<p>Рассмотрим, что отправляется компьютеру при нажатии клавиш. Каждой клавише, очевидно, должен соответствовать некий цифровой код, состоящий из одного или нескольких байт. Дабы избежать всеобщей путаницы с кодами, они были стандартизированы. Для большинства клавиш стандартом является знаменитая 7-битная кодировка <a href="https://en.wikipedia.org/wiki/ASCII">ASCII</a>. Она была специально создана для использования в телетайпах, а потом перекочевала в терминалы. Кодировка состоит из обычных и управляющих символов. Первые 32 символа и последний 128-й являются управляющими - это перевод строки, табуляция, окончание передачи, итд - <a href="https://en.wikipedia.org/wiki/C0_and_C1_control_codes">полный список с описанием</a>. Строго говоря, это не совсем симвлолы в привычном понимании, а управляющие коды с помощью которых можно контролировать работу как компьютера, так и самого терминала. Многие из них не используются по назаначению, так как имеют смысл только для старых “бумажных” телетайпов и терминалов или же просто устарели и более не востребованы. Позже Я подробнее поясню, то как коды этих клавиш обрабатываются компьютером и самим терминалом. Остальные символы - привычные нам печатаемые латинские буквы, цифры, знаки препинания - называются печатаемыми. При нажатии клавишу, например, <code class="language-plaintext highlighter-rouge">q</code> мы отправим его ASCII код <a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C">\x71</a> компьютеру, а при нажатии <code class="language-plaintext highlighter-rouge">Return</code> - код управляющего символа <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82_%D0%BA%D0%B0%D1%80%D0%B5%D1%82%D0%BA%D0%B8">CR</a>: <code class="language-plaintext highlighter-rouge">\x0D</code>.</p>

<p><strong>Важное замечание</strong>: при нажатии любой клавиши, её код отправляется компьютеру, но <strong>не</strong> передаётся экрану терминала, т.е чтобы напечатать введенный символ нужно явно отправить его терминалу из компьютера. Дело в том, что программам далеко не всегда нужно печатать на экран введенные пользователем данные, поэтому для большей гибкости применяется такой подход.</p>

<p>Также существуют т.н функциональные клавиши(стрелки, Escape, Ctrl, Caps Lock итд) - полный список в документации. Некоторые из них не передают никаких символов. Например Caps Lock и Shift - устанавливают регистр буквенных символов(как и по сей день). Отдельно стоит отметить клавишу Ctrl - она используется в связке с другими клавишами для генирования управляющих символов ASCII - в документации таблица 4-2. Механизм её работы таков: она зануляет старший бит кода нажатой вместей с ней клавиши. Напримиер, код клавиши <code class="language-plaintext highlighter-rouge">D</code> - <code class="language-plaintext highlighter-rouge">1000100</code> - при нажатии вместе с Ctrl превращается в <code class="language-plaintext highlighter-rouge">0000100</code> - управляющий символ с названием <code class="language-plaintext highlighter-rouge">EOT</code>. Такой способ ввода управляющих символов используется очень широко и получил собственное обозначение - т.н <a href="https://en.wikipedia.org/wiki/Caret_notation">caret notation</a>, т.е EOT также можно обозначить как <code class="language-plaintext highlighter-rouge">^D</code>.</p>

<p>Для некоторых наиболее часто используемых управляющих символов выделены отдельные клавишы: Back Space, Tab, Esc, Return, Line Feed, Enter(в правом нижнем углу клавиатуры).</p>

<p>Особое внимание стоит уделить клавишам <code class="language-plaintext highlighter-rouge">Return</code>, <code class="language-plaintext highlighter-rouge">Enter</code> и <code class="language-plaintext highlighter-rouge">Line Feed</code>. На современных клавиатурах остались <code class="language-plaintext highlighter-rouge">Return</code>(та, что с изогнутой стрелкой) и <code class="language-plaintext highlighter-rouge">Enter</code>. Мы не совсем осознанно называем клавишу <code class="language-plaintext highlighter-rouge">Return</code> “энтером”, а настоящую клавишу <code class="language-plaintext highlighter-rouge">Enter</code> обычно не используем. Дело в том, что исторически функции этих клавиш были одинаковы, за тем исключением, что <code class="language-plaintext highlighter-rouge">Enter</code> расположена в блоке клавиш под названием <a href="https://en.wikipedia.org/wiki/Numeric_keypad">Numeric Keypad</a>. Numeric Keypad - это своего рода отдельная мини-клавиатура когда-то использовавшаяся для более удобного взаимодействия с некоторыми программами. У неё есть два режима работы. В своём обычном режиме её клавиши генерируют те же коды, что и основная клавиатура, и тогда <code class="language-plaintext highlighter-rouge">Enter</code> <strong>эквивалентен</strong> <code class="language-plaintext highlighter-rouge">Return</code>. Очевидно, название <code class="language-plaintext highlighter-rouge">Enter</code> звучит более выразительно чем <code class="language-plaintext highlighter-rouge">Return</code>, и поэтому мы все используют именно его. Если интересно, то об этом также можно почитать в документации под таблицей 4-2(Я бы не рекомендовал - и так куча всего непонятного).</p>

<p>На клавише <code class="language-plaintext highlighter-rouge">Return</code> не зря изображено стрелка, указывающая налево. Данная клавиша генерирует управляющий символ с кодом <code class="language-plaintext highlighter-rouge">\x0D</code> чаще представляемый как <code class="language-plaintext highlighter-rouge">\r</code>(нотация из языка С). Называется он <code class="language-plaintext highlighter-rouge">carriage return</code>(CR) или “возврат каретки” и, будучу переданным терминалу, указывает ему перевести курсор к началу строки.</p>

<p>Клавиша <code class="language-plaintext highlighter-rouge">Line Feed</code>: здесь все интереснее. Она производит на свет повсеместно используемый управляющий символ <code class="language-plaintext highlighter-rouge">\x0A</code> или <code class="language-plaintext highlighter-rouge">\n</code> в нотации C. Правильно он называется не самым очевидным образом: <code class="language-plaintext highlighter-rouge">Linefeed</code>(LF) - перевод строки. Почему такой клавиши нет на современных клавиатурах? Откуда, в таком случае, мы получаем символ перевода строки? Сейчас расскажу коротко: драйвер терминала(точнее та самая дисциплина линии) заменяет символ клавиши <code class="language-plaintext highlighter-rouge">Return</code> - <code class="language-plaintext highlighter-rouge">\r</code> на <code class="language-plaintext highlighter-rouge">\n</code> или же (в зависимости от настройки) добавляет его после <code class="language-plaintext highlighter-rouge">\r</code> и поэтому клавиша <code class="language-plaintext highlighter-rouge">Line Feed</code> была убрана за ненадобностью. В следующем разделе Я подробнее пройдусь по этому вопросу.</p>

<p>Осталась последняя значимая группа клавиш: стрелки или как их называли тогда - клавишы управления курсором. Для их кодировки используется не ASCII, а специальные последовательности стандарта ANSI(сейчас это стандарт <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">ECMA-48</a>) состоящие из <strong>ASCII символов</strong>. Называются они <code class="language-plaintext highlighter-rouge">ANSI Escape Sequences</code> или “Управляющие последовательнсоти ANSI”. Последовательнстей состоят из трех и более байт. Начинаются они с CSI - Control Sequence Introducer - двух байтов: <code class="language-plaintext highlighter-rouge">\x1B</code> и <code class="language-plaintext highlighter-rouge">[</code>. Первый из них назвается “Escape”(ESC). CSI нужна для того чтобы показать, что следующие символы нужно трактовать особым образом. После CSI идут аргументы последовательнсти, которые и определяют её. Например последовательность <code class="language-plaintext highlighter-rouge">ESC[2J</code> предназначена для стирания содержимого экрана терминала. Кстати, запись вида <code class="language-plaintext highlighter-rouge">\x1B</code> также называется escape последовательнсотью во многих языках программирования.</p>

<p>Небольшое отступление: Стандарт “Управляющих последовательнсотей ANSI” - это своего рода развитие концепции управляющих символов ASII, когда последних стало не достаточно для управления аппаратурой. Стоит отметить, что он включает в себя не только новые многобайтные последовательности, но также и некоторые старые управляющие символы ASII. В этом стандарте их группа называется “C0 control codes”.</p>

<p>Вернёмся к кодировкам наших стрелок. Как Я уже упомянул, их изначальным предназначением явлется управление курсором. Для этого существуют следующие ANSI последовательности:</p>

<p>Здесь CSI это <code class="language-plaintext highlighter-rouge">ESC[</code>.</p>

<p><img src="/assets/img/posts/term/escape_arrows.png" alt="Arrows" /></p>

<p>Как видно из описания этих четырех команд, n - это число клеток для перемещения с дефолтным значением 1. Тогда для перемещения на одну клетку n можно не указывать вовсе - как раз то, что нужно для стрелок. В документации в таблице 4-1 все они перечислены. Итак, нажатие любой из четырех стрелок генерирует трехбайтную последовательнсть отправляемую компьютеру.</p>

<p>Наверняка у вас возникло много вопросов касательно, того, зачем нужны все эти управляющие конструкции как ASCII, так и ANSI. Теперь настало время рассказать об экране нашего терминала.</p>

<h3 id="экран">Экран</h3>

<p>Экран терминала весьма незатейлив. Как Я уже писал, что управлять цветом отдельных пикселей, тут нельзя. Экран поделен на знакоместа сеткой строк и столбцов. Количество столбцов у терминала VT100 80 или 132 в зависимости от настроек. Для указания того знакоместа, где будет напечатан следующий символ существует <code class="language-plaintext highlighter-rouge">курсор</code>, который может перемещаться по знакоместам. Как Вы уже могли догадаться, львиная доля управляющих конструкций предназначена для передвижения курсора по экрану.</p>

<p><a href="https://vt100.net/docs/vt102-ug/chapter5.html">Документация</a> к обработке получаемых терминалом символов.</p>

<p>В начальном сотоянии курсор находится в позиции (0,0) - в левом верхнем углу.</p>

<p>Получая обычный(печатаемый) ASCII символ от компьютера, терминал печатает его на месте курсора и автоматимчески передвигает курсор на следующее знакоместо - было бы странно отправлять 3-х байтную ANSI последовательность перемпщения курсора после каждого символа.</p>

<p>При получении управляющей последовательности ANSI, терминал выполняет соответсвующую функцию. <a href="https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797">Здесь</a> можно посмотреть на них. Большая часть из них отвечает за перемещение курсора и удаление содержимого экрана, но таже есть, например, последовательности с помощью которых можно задавать цвет выводимиого текста.</p>

<p>В предыдущем разделе Я много писал про кнопки <code class="language-plaintext highlighter-rouge">Return</code>/<code class="language-plaintext highlighter-rouge">Enter</code> и <code class="language-plaintext highlighter-rouge">Line feed</code>. 
Кнопка <code class="language-plaintext highlighter-rouge">Return</code> отправляет <code class="language-plaintext highlighter-rouge">\r</code>(CR), а <code class="language-plaintext highlighter-rouge">Line feed</code> - <code class="language-plaintext highlighter-rouge">\n</code>(LF). <code class="language-plaintext highlighter-rouge">\r</code> - даёт команду терминалу вернуть курсор в начало <code class="language-plaintext highlighter-rouge">текущей</code> строки, а <code class="language-plaintext highlighter-rouge">\n</code> - сдвигает курсор на следующую строку, не меняя столбец. То есть для полноценного перевода строки терминалу нужно передать сразу обе этих символа CR и LF. Как Я писал выше, драйвер терминала в Unix-подобных ОС проводит обработку этих символов как при чтении из терминала, так и при записи в него. Это позволяет пользоваться лишь одной клавишей <code class="language-plaintext highlighter-rouge">Enter</code> и записывать в терминал только <code class="language-plaintext highlighter-rouge">\n</code> для перевода строки. Стоит заметить, что в других системах, например, Windows, требуется выводить сразу <code class="language-plaintext highlighter-rouge">\r\n</code>.</p>

<h2 id="эмуляторы-терминалов">Эмуляторы Терминалов</h2>

<p>В 80-х годах с развитием графических интерфейсов, терминалы были заменены на мониторы и клавиатуры общего назаначения, существующие и по сей день. К тому моменту уже существовало множество программ, нацеленных на работу именно с терминалом. Среди них крайне важные: текстовые редакторы(vi), командные оболочки(shell). Даже внутри Unix-подобных ОС появился ряд функций, заточенных под работу с терминалом. Да и вообще: сам способ терминального ввода/вывода отличался широкими возможностями при относительной простоте взаимодействия. Поэтому в таких системах терминалы начали реализовывать программно. Такие программы называюся эмуляторами терминалов или вртуальным терминалом в противовес обычным(физическим) терминалам. Связка клавиатура, монитора и эмулятора терминала по своим возможностям соответствует физическому терминалу.</p>

<p>Обычные терминалы помимо наличия монитора и клавиатуры обладают особой функциональностью, которую Я описывал ранее. Теперь же у нас есть только клавиатура, умеющая передавать коды символов, почти так же как и клвиатура терминала, но монитор, стал совсем “тупым” - он умеет только отрисовывать пиксели. Эмуляторы терминалов компенсируют эту утраченную функциональность.</p>

<p><img src="/assets/img/posts/term/term_emul.png" alt="Emul Terminal" /></p>

<p>На схеме выше изображена схема <code class="language-plaintext highlighter-rouge">подсистемы tty</code> встроенной в ядро ОС Linux. Как можно заметить, Terminal emulator принимает ввод с клавиатуры и выводит изображение на экран с помощью соответсвубщих драйверов. Обмен данными с драйвером терминала теперь реализуется в ядре ОС, без участия линии UART.</p>

<p>В ОС Linux вышеописаная система существует и по сей день. Называется она “Linux console” или просто - консолью. В самом начале Я упоминал, в каких случаях используется название “консоль” вместо “терминал”. Здесь как раз похожий случай, так как данная система - это единственный способ связи пользователя с ОС встроенный непосредственно в неё. Вы можете преклчиться на один из таких терминалов(их несколько) с помощью сочетания клвавиш Ctrl-Alt-F[1-6]. Однако сегодня мы в большинсттве случаев используеи графический интерфейс рабочего стола при работе с ОС. Как же нам получить доступ к эмулятору терминала оттуда, не прибегая к переключению на системную консоль Linux?</p>

<p>Программу эмулятор терминала можно создать в качестве пользовательского процесса, наравне с другими графическими приложениями, вроде браузера или текстового редактора. Пример такой программы на схеме выше - xterm. Напомню, что эмулятор терминала, будь то пользовательский или системный, выполняет функции физического терминала, но для полноценной работы он должен взаимодействовать с драйвером терминала. У системного терминала(консоли) с этим проблем нет, но пользовательское приложение может быть только конечной точкой взаимодействия(см. схемы) и не может само выполнять роль эмулятора терминала. Для решения этой проблемы был придуман механизм <code class="language-plaintext highlighter-rouge">псевдотерминалов</code>. Он позвволяет пользовательскому процессу получить доступ к <code class="language-plaintext highlighter-rouge">драйверу терминала(дисциплине линии)</code> с обеих сторон взаимодействия(см. схему ниже)</p>

<p><img src="/assets/img/posts/term/pty.png" alt="pty" /></p>

<h2 id="драйвер-терминала-или-дисциплина-линии">Драйвер терминала или дисциплина линии</h2>

<p>Драйвер терминала является связующим звеном между терминалом и программой. Он выполняет обработку входных и выходных данных. Я буду опираться на книгу М. Керриска, рекомендую заглянуть в главу о терминалах. Драйвер можно настраивать с помощью специальной структуры <code class="language-plaintext highlighter-rouge">termios</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct termios
  {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;			/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
  };
</code></pre></div></div>

<p>При запуске процесса из командной строки, эта структура(т.е настройки драйвера терминала) будут иметь дефолтное значние. При изменеии настроек драйвера вызовом <code class="language-plaintext highlighter-rouge">tcsetattr</code>, все процессы, использующие этот терминал, увидят изменения этих настроек.</p>

<p>Наибольшый интерес представляют поля: <code class="language-plaintext highlighter-rouge">c_iflag</code> - содержит функции обработки для входного потока символов, <code class="language-plaintext highlighter-rouge">c_oflag</code> - для выходного потока символов, <code class="language-plaintext highlighter-rouge">c_lflag</code> - для режима работы терминала, <code class="language-plaintext highlighter-rouge">c_cc</code> - содержит значения специальных символов терминала(об этом далее).</p>

<p>Драйвер терминала определяет набор специальных “символов”, принимая которые, он будет выполнять определенные действия. Кавычки Я добавил потому, что эти “символы” имеют определенное название, но их конкретное значение можно задать с помощью массива <code class="language-plaintext highlighter-rouge">c_cc</code>, кроме <code class="language-plaintext highlighter-rouge">CR</code> и <code class="language-plaintext highlighter-rouge">NL</code> - их значения фиксированы(<code class="language-plaintext highlighter-rouge">\r</code> и <code class="language-plaintext highlighter-rouge">\n</code>). Такой механизм позволяет гибче настраивать драйвер. Большая часть специальных символов имеют дефолтные значения.</p>

<p>В <code class="language-plaintext highlighter-rouge">c_lflag</code> содержатся такие важные функции как:</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ECHO</code> - в включенном состоянии, автоматически отправяет терминалу, символы введенные пользователем. Непечатаемые символы отображаются в виде <code class="language-plaintext highlighter-rouge">^{A-^}</code>. Эта функция включена по умолчанию. Если её выключить, то программе нужно будет самой отправлять терминалу нужные для печати символы.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ICANON</code> - включает т.н канонический режим работы драйвера. Включен по умолчанию. У драйвера терминала есть специальный буфер для входных данных. В этом режиме драйвер не даёт доступ пользовательскому к данным во входном буфере сразу, а только после ввода специального символа перевода строки <code class="language-plaintext highlighter-rouge">NL</code> или специального символа <code class="language-plaintext highlighter-rouge">EOF</code>. Пока не введены эти сиволы, введенную строку можно редактировать: стирать символ, слово или всю строку, но перемещение курсора по строке не доступно. Такой подход позволяет многим пользовательским программам не реализовывать редактирование строки, а просто воспользоваться данным режимом. Для более продвинутого редактирования строки, такой режим нужно отключить и реализоваит весь функционал непосредственно в программе. Стоит отметить, что символ <code class="language-plaintext highlighter-rouge">NL</code> добавляется в буфер, а <code class="language-plaintext highlighter-rouge">EOF</code> - нет.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ISIG</code> - включает возможность отправлять сигналы процессам, испоьзующим данный терминал. Например, при получении символа с <code class="language-plaintext highlighter-rouge">INTR</code>, имеющем дефолтное значене Ctrl-C(<code class="language-plaintext highlighter-rouge">^C</code>), отправляется сигнал <code class="language-plaintext highlighter-rouge">SIGINT</code>, а при получении символа <code class="language-plaintext highlighter-rouge">SUSP</code> - <code class="language-plaintext highlighter-rouge">SIGTSTP</code>.</p>
  </li>
</ol>

<p>В <code class="language-plaintext highlighter-rouge">c_iflag</code> содержатся такой важный флаг, как <code class="language-plaintext highlighter-rouge">ICRNL</code>(включен по умолчанию). При активном флаге, драйвер терминала заменяет символ <code class="language-plaintext highlighter-rouge">CR</code>(<code class="language-plaintext highlighter-rouge">\r</code>) на  <code class="language-plaintext highlighter-rouge">NL</code>(<code class="language-plaintext highlighter-rouge">\n</code>). Аналогичный флаг <code class="language-plaintext highlighter-rouge">ONLCR</code> содержится в <code class="language-plaintext highlighter-rouge">c_oflag</code>. Если включён, то драйвер заменят <code class="language-plaintext highlighter-rouge">NL</code> на <code class="language-plaintext highlighter-rouge">CRNL</code> при выводе.</p>

<p>Еще немного про флаг <code class="language-plaintext highlighter-rouge">ICANON</code>…</p>]]></content><author><name></name></author></entry><entry><title type="html">Заметки о GNU Make</title><link href="https://bigyin1.github.io//2022/07/26/Make.html" rel="alternate" type="text/html" title="Заметки о GNU Make" /><published>2022-07-26T00:00:00+00:00</published><updated>2022-07-26T00:00:00+00:00</updated><id>https://bigyin1.github.io//2022/07/26/Make</id><content type="html" xml:base="https://bigyin1.github.io//2022/07/26/Make.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#полезные-ссылки" id="markdown-toc-полезные-ссылки">Полезные ссылки</a></li>
  <li><a href="#зачем-нужен-make" id="markdown-toc-зачем-нужен-make">Зачем нужен Make?</a></li>
  <li><a href="#подробнее-о-правилах" id="markdown-toc-подробнее-о-правилах">Подробнее о правилах.</a></li>
  <li><a href="#переменные-и-функции" id="markdown-toc-переменные-и-функции">Переменные и функции</a></li>
</ol>

<h2 id="полезные-ссылки">Полезные ссылки</h2>

<ol>
  <li><a href="https://interrupt.memfault.com/blog/gnu-make-guidelines">Хорошая статья</a></li>
  <li><a href="https://makefiletutorial.com/">Другая хорошая статья</a></li>
  <li>Примеры использования make для C-проектов: <a href="https://github.com/memfault/zero-to-main">1</a> <a href="https://github.com/levex/levos7">2</a> <a href="https://github.com/edosedgar/stm32f0_ARM/tree/master/labs">3</a></li>
  <li><a href="https://www.gnu.org/software/make/manual/html_node/index.html#SEC_Contents">Документация</a></li>
</ol>

<h2 id="зачем-нужен-make">Зачем нужен Make?</h2>

<p>GNU Make представляет собой одну из первых систем автоматизации сборки. Сборки чего? - спросите вы. Ответ прост - файлов, которые являются продуктом таких программ как: компиляторы, линковщики, генераторы документации, текстовые редакторы, тестовые утилиты, шаблонизаторы и др. Все они генерируют выходные файлы на основе некоторых входных файлов.</p>

<p>В чем же здесь проблема? Ведь для подобной сборки достаточно обычного bash-скрипта. Действительно, это так, но такой скрипт будет запускать все инструкции сборки при каждом вызове. Например, изменив что-либо в одном из файлов и запустив скрипт, мы запустим пересборку всех файлов проекта, хотя это требовалось лишь для одного из них. Именно эту проблему решает Make.</p>

<p>Make принимает на вход т.н Makefile. Основным строительным блоком Makefile-а являются <code class="language-plaintext highlighter-rouge">правила</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main.o: main.c
	gcc -c main.c -o main.o
</code></pre></div></div>

<p>Такие правила называются явным. Также существуют <a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Rules.html#Implicit-Rules">неявные правила</a>(о них будет рассказано ниже).
Деление на явные и неявные правила влияет только на приоритетность поиска правил для цели.
Помимо целевого файла - <code class="language-plaintext highlighter-rouge">target</code> и инструкций по его сборке - <code class="language-plaintext highlighter-rouge">recipe</code>, перечислены зависимости цели - <code class="language-plaintext highlighter-rouge">prerequisites</code>. Как правило это входные файлы для команд в recipe (main.c в примере выше). Эта информация и позволяет решить описанную выше проблему.</p>

<p>Make собирает цель следующим образом:</p>

<ol>
  <li>Поиск правила для цели. Одна цель может подходить под несколько правил. При поиске первый приоритет дается явным правилам.
    <ul>
      <li>Если целевой файл не существует и правило для него не найдено, то make завершается с ошибкой.</li>
      <li>Если целевой файл уже существует, а правила для него нет, то его обработка завершается и make продолжает свою работу. Такой вариант развития событий в большинстве случаев применяется к файлам исходного кода.</li>
      <li>Также есть алгоритм действий для случаев, когда для одной цели <a href="https://www.gnu.org/software/make/manual/html_node/Multiple-Rules.html#Multiple-Rules">подходит несколько правил</a>, но такого поведения следует избегать.</li>
    </ul>
  </li>
  <li>
    <p>Для каждой зависимости из правила make запускает этот же алгоритм сборки цели, где целью является сама зависимость.</p>
  </li>
  <li>Теперь самое интересное: если целевой файл не существует или хотя бы одна из уже собранных зависимостей новее целевого файла, то происходит выполнение команд recipe.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prog: main.o utils.o
    ld main.o utils.o -o prog

main.o: main.c
	gcc -c main.c -o main.o

utils.o: utils.c
	gcc -c utils.c -o utils.o
</code></pre></div></div>

<p>Так при сборке цели <code class="language-plaintext highlighter-rouge">prog</code>, при первом вызове будут выполнены все команды, при повторном вызове в отсутсвии изменеий в исходных файлах, не будет выполнена ни одна. При внесении изменений в один из исходных файлов, будет выполнена компиляция только для него и линковка исполняемого файла <code class="language-plaintext highlighter-rouge">prog</code>.</p>

<p>Как можно заметить, make выстраивает ациклический граф зависимостей. Вершинами этого графа, которые не зависят от других, являются, в нашем случае, файлы исходного кода. Остальные вершины являются целями с зависимостями, которые пересобираются только при своих изменеии зависимостей.</p>

<p>Для небольших проектов выгода такого подхода будет едва ли заметна, но полная пересборка большого проекта может занимать часы, и без подобной системы работа с ним была бы крайне затруднена. Кстати, эта одна из причин почему код проекта следует распределять по файлам.</p>

<p>Также в make есть возможность задать target не как имя выходного файла, а как имя некотрого действия. Например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.PHONY: install
install: prog
	cp prog /usr/bin
</code></pre></div></div>

<p>Такая цель считается всегда устаревшей, а также make не будет брать во внимание возможные файлы с таким же именем как и у этой цели.</p>

<p>Важно отметить, что все свои операции make производит относительно текущей рабочей директории. Для её изменения нужно вызвать make следующим образом: <code class="language-plaintext highlighter-rouge">make -C somedir</code></p>

<h2 id="подробнее-о-правилах">Подробнее о правилах.</h2>

<p>Как можно заметить, в предыдущем примере правила для main.o и utils.o отличаются лишь именами соответствующих файлов. В make для обобщения подобных правил существует механизм шаблонных правил. Шаблонные правила относятся к <code class="language-plaintext highlighter-rouge">неявным правилам</code>.</p>

<p>Пример выше будет выглядет следующим образом при исрользовании шаблонов:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>prog: main.o utils.o
    ld main.o utils.o -o prog

%.o: %.c
	gcc -c $&lt; -o $@
</code></pre></div></div>

<p>Под шаблон <code class="language-plaintext highlighter-rouge">%.o</code> попадаёт любой файл оканчвающийся на <code class="language-plaintext highlighter-rouge">.o</code>. Именем файла в данном случае является путь к нему относительно рабочей директории make, т.е и файл main.o и, например, build/main.o попадают под данный шаблон. Далее из имени файла make получает ту его часть, которая соответсвует шаблонному символу - <code class="language-plaintext highlighter-rouge">%</code> (в нашем случае это будет строка main или build/main) и подставляет на место того же <code class="language-plaintext highlighter-rouge">%</code> в шаблон списка зависимостей. Несколько подробнее об этом <a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Intro.html#Pattern-Intro">здесь</a>.</p>

<p>При написании шаблонных правил нам неизвестны имена цели и зависимостей, поэтому для получения этих имен нужно пользоваться т.н автоматическими переменными, которые устанавливает make при выполнении правила. В примере выше это <code class="language-plaintext highlighter-rouge">$&lt;</code> - содержит имя первой зависимости (например main.c), <code class="language-plaintext highlighter-rouge">$@</code> - имя цели. <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables">Полный список автоматических переменных</a>.</p>

<p>Также к неявным правилам относятся несколько <a href="https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html#Catalogue-of-Rules">встроенных</a> правил для компиляции и сборки C/C++ и некотрых других языков. Скорее всего название “неявные правила” было дано им именно поэтому, хотя логичнее,все же, было бы называть их шаблонными правилами.</p>

<h2 id="переменные-и-функции">Переменные и функции</h2>

<p>Существуют и обычные переменные. Для примера выше можно записать:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC = gcc
LD = ld
OBJS = main.o utils.o

prog: $(OBJS)
    $(LD) $(OBJS) -o prog

%.o: %.c
	$(CC) -c $&lt; -o $@
</code></pre></div></div>

<p>Хорошей практикой считается перечисление только исходных файлов проекта, а имена соответствующих объектных файлов(и многих других файлов, производимых программами) генерируются автоматически.</p>

<p>Для этого в make есть ряд <a href="https://www.gnu.org/software/make/manual/html_node/Functions.html#Functions">встроенных функций</a> для преобразования текста.</p>

<p>Используем функцию pattern substitution(patsubst)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC = gcc
LD = ld

SRCS = main.c utils.c
OBJS = $(patsubst %.c,%.o,$(SRCS))

prog: $(OBJS)
    $(LD) $(OBJS) -o prog

%.o: %.c
	$(CC) -c $&lt; -o $@
</code></pre></div></div>

<p>Переменные и функции позволяет еще больше обобщить правила. Теперь в переменную SRCS можно добавлять новые исходные файлы проекта.</p>]]></content><author><name></name></author></entry><entry><title type="html">Заметки о Git</title><link href="https://bigyin1.github.io//2022/05/25/Git.html" rel="alternate" type="text/html" title="Заметки о Git" /><published>2022-05-25T00:00:00+00:00</published><updated>2022-05-25T00:00:00+00:00</updated><id>https://bigyin1.github.io//2022/05/25/Git</id><content type="html" xml:base="https://bigyin1.github.io//2022/05/25/Git.html"><![CDATA[<p>Некоторые заметки о сложной и важной системе.</p>

<ol>
  <li>Сначала полезные ссылки по теме:</li>
</ol>

<ul>
  <li><a href="https://git-scm.com/book/en/v2">Git Book</a> - неплохо изложены основные положения.</li>
  <li>Очень хорошие статьи с подробным объяснением ряда основных моментов: <a href="https://www.biteinteractive.com/picturing-git-conceptions-and-misconceptions/">1</a>, <a href="https://www.biteinteractive.com/understanding-git-merge/">2</a> и <a href="https://www.biteinteractive.com/of-git-and-github-master-and-main/">3</a></li>
  <li><a href="https://www.youtube.com/watch?v=fBP18-taaNw">Видео</a> с объяснением некоторых продвинутых вещей</li>
  <li><a href="https://docs.github.com/en/get-started">Документация GitHub</a>, осбенно советую прочитать <a href="https://docs.github.com/en/get-started/getting-started-with-git">этот</a> раздел- там много информации о работе с удаленными репозиториями.</li>
  <li><a href="https://git-scm.com/docs">Полная документация</a></li>
</ul>

<ol>
  <li>
    <p>Для чего же нужен Git?</p>

    <ol>
      <li>
        <p>Git позвоялет сохранить состояние вашего проекта. Это дает Вам возможность понять, какие именно изменения были сделаны с момента последеней рабочей версии или перейти на какую либо версию проекта.
 Для маленьких проектов польза этого может быть и не столь заметна.</p>
      </li>
      <li>
        <p>Механизм веток позволяет независимо работать над разными частями проекта.</p>
      </li>
      <li>
        <p>Ваш локальный репозиторий можно связать с удаленными, и синхронизировать изменения между ними(т.е отправлять и получать новые коммиты, ветки итд).</p>
      </li>
      <li>
        <p>2-й и 3-й пункты делают возможной относительно удобную командную разработку.</p>
      </li>
    </ol>
  </li>
  <li>
    <p>Важное свойство удаленных репозиториев:</p>

    <p>Ветки на удаленном репозитории при синхронизации с локальным с помощью команды <code class="language-plaintext highlighter-rouge">git push</code> могут перемещаться только вперед (fast-forward), истинный merge недопустим, и git потребует от вас сделать этот merge локально с помощью <code class="language-plaintext highlighter-rouge">git pull</code>. Также недопустим откат удаленной ветки назад, в том случае, если оный был совершен локально с помощью <code class="language-plaintext highlighter-rouge">git reset</code>.</p>
  </li>
  <li>
    <p>Механизм подмодулей:</p>

    <p>Помимо других применений, позволяет неплохо управлять зависимостями(устанавливать и обновлять библиотеки проекта) там, где такого механизма нет(C/С++).</p>
  </li>
</ol>]]></content><author><name></name></author><summary type="html"><![CDATA[Некоторые заметки о сложной и важной системе.]]></summary></entry><entry><title type="html">Об адресах в компьютере. Часть 1.</title><link href="https://bigyin1.github.io//2021/09/25/Addresses.html" rel="alternate" type="text/html" title="Об адресах в компьютере. Часть 1." /><published>2021-09-25T00:00:00+00:00</published><updated>2021-09-25T00:00:00+00:00</updated><id>https://bigyin1.github.io//2021/09/25/Addresses</id><content type="html" xml:base="https://bigyin1.github.io//2021/09/25/Addresses.html"><![CDATA[<ol id="markdown-toc">
  <li><a href="#основные-идеи" id="markdown-toc-основные-идеи">Основные идеи</a></li>
  <li><a href="#взаимодействие-с-переферией" id="markdown-toc-взаимодействие-с-переферией">Взаимодействие с переферией</a></li>
  <li><a href="#немного-про-сам-процессор" id="markdown-toc-немного-про-сам-процессор">Немного про сам процессор</a></li>
</ol>

<p>Здесь Я постаряюсь подробно описать основные механизмы взаимодействия процессора и переферийных устройств, так как, на мой взгляд, эта тема плохо освещается в большинстве академических курсов.</p>

<h2 id="основные-идеи">Основные идеи</h2>

<p>Процессор, программы для которого мы в большинстве случаев пишем, является сложным электронным устройством, но сам по себе он умеет совсем немного:
исполнять свои инструкции и отправлять или считывать электрические сигналы со своих многочисленных контактов. Этого явно не достаточно для того чтобы такая система звалась компьютером. Как минимум требуется подключить память, иначе будет негде хранить данные и инструкции, а без них процессор не имеет смысла.</p>

<p>Но вот вопрос: как организовать подключение памяти и взаимодействие с ней? Для этого придумали невероятно простой и изящный механизм. Весь “внешний мир” процесса представляется ему как массив двоичных состояний - битов. Выше Я упомянул лишь память, но к процессору, как правило, подключаются много других устройств и красота такого механизма проявляется в абсолютной независимости процессора от типа подключаемого устройства. Все они(даже оперативная память, занимающая особое положение) представлены процессору как набор переключателей с двумя положениями. Ниже, я подробней расскажу об этом.</p>

<p>Чтобы иметь возможность взаимодействовать с конкретным битом требуется механизм их адресации.
Сам способ адресации весьма прост: индексирование от 0 до максимального адреса. Само же взаимодействие заключается в двух возможных действиях со стороны процессора: чтение состояния с адреса и запись по адресу. Подробнее об этом позже.</p>

<p>Я здесь про отдельные биты рассказываю, но как вы знаете, современные компьютеры оперируют группами сразу из нескольких бит. Такая группа называется Minimum Addressable Unit (MAU) и на сегодняшний день равна 8 битам, но так было далеко не всегда. <a href="https://en.wikipedia.org/wiki/Word_addressing">Здесь</a> и <a href="https://en.wikipedia.org/wiki/Byte_addressing">здесь</a> можно подробно прочитать об этом.
Массив всех MAU до которых способен дотянуться процессор называется физическим адресным пространством(почему оно физическое расскажу позже).
Используя 8 битный MAU, мы увеличиваем физическое адресное пространство в 8 раз при том же количестве адресов, в сравнении с использованием 1 бита в качестве MAU, но при этом усложняется и замедляется взаимодействие с отдельными битами. Это наиболее заметно при работе с массивами из boolean элементов. Синонимом MAU является <code class="language-plaintext highlighter-rouge">байт</code>. Есть разные версии того почему размер байта(MAU) в итоге выбрали именно в 8 бит. Наиболее вероятная - это широко используемая 8-битная кодировка <a href="https://en.wikipedia.org/wiki/Extended_ASCII">Extended ASCII</a>.</p>

<p>Само физическое адресное пространство формируется адресными контактами процессора(для отдельно взятого процессора, это просто набор контактов, не имеющих смысла при отсутствии подключенных устройств). Желая взаимодействовать с конкретным адресом, процессор выводит его с их помощью, а подключенные к этим контактам устройства, уже распознают свой адрес. Подробнее об этом я расскажу в следующей статье.</p>

<h2 id="взаимодействие-с-переферией">Взаимодействие с переферией</h2>

<p>Вернемся к переферийным устройствам. Хорошо, со стороны процессора мы имеем физическое адресное пространство, но как его “соединить” с внешними устройствами?
Здесь также был придуман весьма изящный способ: каждое переферийное устройство обладает набором тех самых переключателей - битов. За каждым из этих переключателей стоит некое реальное действие. Самое простое - это обычное сохранение последнего записанного состояния, как это делает RAM.</p>

<p>В электронике, устройство хранящее цифровую информацию называется <code class="language-plaintext highlighter-rouge">регистром</code>. Каждое переферийное устройство с которым взаимодействует процессор, имеет хотя бы один регистр с помощью которого они могут взаимодействовать(т.е обмениваться данными) с процессором. Регистры могут иметь разную разрядность, в зависости от контролируемой ими функции. Например, для светодиода необходимо и достаточно одного регистра разрядностью 1 бит. Именно регистры и занимают “места” в физическом адресном пространстве процессора.</p>

<p>Нужно вспомнить об вышеупомянутом MAU в 1 байт. Регистры непосредственно затронуты этой интересной особенностью и взаимодействовать с одним их битом за раз не получится: поэтому <code class="language-plaintext highlighter-rouge">регистры</code> имеют размер кратный 1-му байту(даже там где это избыточно). Как правило, регистр состоит из битов объединенных общим предназначением. Наиболее яркий пример это оперативная память, которая, по сути, является одним большим регистром данных (да, регистры вовсе не ограничены длиной в 8, 32 или 64 бита). В других переферийных устройствах, например таймерах, есть т.н конфигурационные регистры с помощью которых его можно настроить, запустить или остановить.</p>

<p>Представьте, все это похоже на то как мы взаимодействуем с различными механизмами. Например СВЧ печь: различные кнопки управления на ней это регистры конфигурации, а внутреннее отделение печи это, своего рода, регистр данных в который мы загружаем сырую еду. Еще пример - школьная доска, которая является логическим аналогом оперативной памяти, будучи одним большим регистром данных, сохраняющим последнее записанное значение.</p>

<p>Более подробно рассмотрим одно из самых простых и распространенных переферийных устройств - порт ввода-вывода общего назначения (GPIO)</p>

<p><img src="/assets/img/posts/addrs/addr_gpio.png" alt="GPIO" /></p>

<p>Он представляет из себя группу контактов на каждом из которых можно выводить логический уровень(0 или 1) или считывать его из вне. Для управления им необходимо 2 регистра: регистр данных(DR) и т.н Data Direction Register.
Каждый бит этих регистров управляет соответствующим контактом: бит в DDR задает режим работы контакта(1 если на вывод, 0 если на ввод), а бит в DR содержит текущий логический уровень выводимый нами(DDR=1) или вводимый из вне(DDR=0).
Вышеописанные регистры занимают свои места в физическом адресном пространстве нашего процессора. Теперь записи и чтения по этим адресам будут контролировать работу нашего устройства GPIO.</p>

<p>Давайте взглянем на происходящее несколько шире:</p>

<p><img src="/assets/img/posts/addrs/addr_space.png" alt="UML Addr Space" /></p>

<p>На вышепредставленной картинке в форме UML представлены(на сколько возможно) отношения между процессором, его физическим адресным пространством и переферией. Ключевой фигурой здесь является интерфейс Byte - как легко догадаться, он описывает интерфейс одного байта из адресного пространства. Адресное пространство, в таком случае, есть массив этих интерфейсов, а переферийные устройства реализуют некоторые интерфейсы из этого массива, то есть на места “виртуальных”, байтов встают реальные регистры. Здесь можно заметить одну интересную особенность: реализацию <code class="language-plaintext highlighter-rouge">принципа инверсии зависимостей</code> в отношении процессора и переферии, и все благодаря механизму адресного пространства. В результате ни процессор ни переферия не зависят друг от друга, что дает свободу манёвра в плане различных взаимодействий между ними.</p>

<h2 id="немного-про-сам-процессор">Немного про сам процессор</h2>
<p>В Intel® 64 and IA-32 Architectures Software Developer’s Manual есть интересная схема, демонстрирующая то чем процессор предстаёт для исполняемой им программы:</p>

<p><img src="/assets/img/posts/addrs/EE.png" alt="EE" width="400" height="589" /></p>

<p>Что не удивительно, здесь опять все заполнено знакомыми нам регистрами, а в правом верхнем углу…(ну вы поняли).
Регистры процессора служат тем же целям, что и в переферийных устройствах - формируют его интерфейс. Отличие состоит в том, что процессор, очевидно, хорошо осведомлен о своём внутреннем устройстве и, поэтому, побайтовая адресация не требуется, адресовать его регистры можно целиком(т.е каждый адрес соответсвует целому регистру процессора, а не байту). Можно сказать, что совокупный набор регистров процессора составляет, своего рода, отдельное адресное пространство.</p>]]></content><author><name></name></author></entry></feed>